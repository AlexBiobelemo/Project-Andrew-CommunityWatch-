{% extends "base.html" %}

{% block content %}
    <div id="map" data-issues='{{ issues_data | tojson }}'></div>

    <div class="modal fade" id="reportModal" tabindex="-1" aria-labelledby="reportModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="reportModalLabel">Report a New Issue</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="issue-form" enctype="multipart/form-data">
                        {{ issue_form.hidden_tag() }}
                        <input type="hidden" id="lat-input" name="lat">
                        <input type="hidden" id="lng-input" name="lng">

                        <div class="mb-3">
                            {{ issue_form.category.label(class="form-label") }}
                            {{ issue_form.category(class="form-select") }}
                        </div>

                        <div class="mb-3">
                            {{ issue_form.location_text.label(class="form-label") }}
                            {{ issue_form.location_text(class="form-control", id="location-text", readonly=True) }}
                        </div>

                        <div class="mb-3">
                            {{ issue_form.description.label(class="form-label") }}
                            {{ issue_form.description(class="form-control", rows="3") }}
                        </div>
                        <div class="mb-3">
                            {{ issue_form.photo.label(class="form-label") }}
                            {{ issue_form.photo(class="form-control") }}
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="submit-issue-btn">Submit Report</button>
                </div>
            </div>
        </div>
    </div>

    <style>
        /* Style for custom Leaflet controls */
        .leaflet-control-locate a {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 34px;
            height: 34px;
            background-color: #fff;
            border: 2px solid rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        .leaflet-control-locate a:hover {
            background-color: #f4f4f4;
        }
    </style>

    <script>
        // --- MAP INITIALIZATION ---
        const mapElement = document.getElementById('map');
        const map = L.map('map').setView([4.9248, 6.2647], 13);
        const reportModal = new bootstrap.Modal(document.getElementById('reportModal'));

        // --- DRAWING TOOLS INITIALIZATION ---
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        const drawControl = new L.Control.Draw({
            edit: {
                featureGroup: drawnItems
            },
            draw: {
                polygon: true,
                polyline: true,
                rectangle: true,
                circle: false,
                marker: false // We use our own click-to-report for markers
            }
        });
        map.addControl(drawControl);

        // --- EVENT LISTENER FOR WHEN A SHAPE IS CREATED ---
        map.on(L.Draw.Event.CREATED, function (event) {
            const layer = event.layer;
            drawnItems.addLayer(layer);

            // Get the shape's data
            const geojson = layer.toGeoJSON();
            const center = layer.getBounds().getCenter();

            // Set the hidden form fields
            document.getElementById('lat-input').value = center.lat;
            document.getElementById('lng-input').value = center.lng;

            // Add a new hidden input for geojson if it doesn't exist
            let geojsonInput = document.getElementById('geojson-input');
            if (!geojsonInput) {
                geojsonInput = document.createElement('input');
                geojsonInput.type = 'hidden';
                geojsonInput.id = 'geojson-input';
                geojsonInput.name = 'geojson';
                issueForm.appendChild(geojsonInput);
            }
            geojsonInput.value = JSON.stringify(geojson.geometry);

            // Open the reporting modal
            reportModal.show();
        });

        // --- DEFINE MAP LAYERS ---
        const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors'
        });

        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });

        const terrainLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
	        maxZoom: 17,
	        attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        });

        // Add the default layer to the map
        streetLayer.addTo(map);

        // --- CREATE LAYER CONTROL ---
        const baseMaps = {
            "Street View": streetLayer,
            "Satellite View": satelliteLayer,
            "Terrain View": terrainLayer
        };

        L.control.layers(baseMaps).addTo(map);


        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        // Custom Locate Control
        L.Control.Locate = L.Control.extend({
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-locate');
                const button = L.DomUtil.create('a', 'leaflet-bar-part', container);
                button.href = '#';
                button.title = 'Go to my location';
                button.innerHTML = '<i class="bi bi-crosshair" style="font-size: 1.2rem;"></i>';
                L.DomEvent.on(button, 'click', this._locate, this);
                return container;
            },
            _locate: function(e) {
                L.DomEvent.preventDefault(e);
                if (!navigator.geolocation) {
                    alert("Geolocation is not supported by your browser.");
                    return;
                }
                navigator.geolocation.getCurrentPosition(
                    position => {
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        this._map.setView([lat, lng], 16);
                        L.marker([lat, lng]).addTo(this._map)
                            .bindPopup("You are here.").openPopup();
                    },
                    error => {
                        let message = "Unable to retrieve your location.";
                        if (error.code === error.PERMISSION_DENIED) {
                            message = "Geolocation permission denied. Please enable location services.";
                        } else if (error.code === error.POSITION_UNAVAILABLE) {
                            message = "Location information is unavailable.";
                        } else if (error.code === error.TIMEOUT) {
                            message = "The request to get your location timed out.";
                        }
                        alert(message);
                    },
                    { timeout: 10000, enableHighAccuracy: true }
                );
            }
        });
        L.control.locate = function(opts) {
            return new L.Control.Locate(opts);
        };
        L.control.locate({ position: 'bottomright' }).addTo(map);

        // GeoSearch Control
        if (typeof GeoSearch !== 'undefined') {
            try {
                const searchProvider = new GeoSearch.OpenStreetMapProvider();
                const searchControl = new GeoSearch.GeoSearchControl({
                    provider: searchProvider,
                    style: 'button', // Use 'button' for the icon, or 'bar' for a search bar
                });
                map.addControl(searchControl);

                // Add event listener to stop propagation from search control
                map.on('layeradd', function(e) {
                    if (e.layer instanceof GeoSearch.GeoSearchControl) {
                        const searchContainer = document.querySelector('.geosearch-bar');
                        if (searchContainer) {
                            L.DomEvent.on(searchContainer, 'click', function(e) {
                                L.DomEvent.stopPropagation(e);
                            }, this);
                        }
                    }
                });
            } catch (error) {
                console.error('Error initializing GeoSearchControl:', error);
                console.warn('Search functionality is unavailable.');
            }
        } else {
            console.warn('GeoSearch library not loaded. Search control disabled.');
        }

        // Display existing issues
        let issuesData;
        try {
            issuesData = JSON.parse(mapElement.dataset.issues);
        } catch (error) {
            console.error('Error parsing issues data:', error);
            issuesData = [];
        }

        const statusIcons = {
            'Reported': new L.Icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
            }),
            'In Progress': new L.Icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
            }),
            'Resolved': new L.Icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
            })
        };
        const defaultIcon = statusIcons['Reported'];

        // 1. Create a marker cluster group
        const markers = L.markerClusterGroup();

        issuesData.forEach(function(issue) {
            if (!issue.lat || !issue.lng || !issue.id) {
                console.warn('Invalid issue data:', issue);
                return;
            }
            const icon = statusIcons[issue.status] || defaultIcon;
            let buttonClass = issue.user_has_voted ? 'btn-primary' : 'btn-outline-primary';
            let popupContent = `
                <b>${issue.title || 'Untitled'}</b>
                <hr class="my-1">
                <div class="d-flex justify-content-between align-items-center">
                    <span id="upvote-count-${issue.id}">${issue.upvotes || 0} Upvotes</span>
                    <button class="btn btn-sm ${buttonClass} upvote-btn" data-issue-id="${issue.id}">
                        <i class="bi bi-hand-thumbs-up"></i> Vote
                    </button>
                </div>
                <a href="/issue/${issue.id}" class="btn btn-outline-secondary btn-sm mt-2 w-100">View Details</a>
            `;

            // 2. Create the marker and add it to the CLUSTER GROUP, not the map
            const marker = L.marker([issue.lat, issue.lng], { icon })
                .bindPopup(popupContent);
            markers.addLayer(marker);
        });

        // 3. Add the entire cluster group to the map
        map.addLayer(markers);


        // Upvote functionality
        async function upvoteIssue(issueId) {
            try {
                const response = await fetch(`/upvote/${issueId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin'
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (data.success) {
                    const countEl = document.getElementById(`upvote-count-${issueId}`);
                    if (countEl) countEl.innerText = `${data.upvote_count} Upvotes`;
                    const button = document.querySelector(`.upvote-btn[data-issue-id="${issueId}"]`);
                    if (button) {
                        button.classList.toggle('btn-primary', data.voted);
                        button.classList.toggle('btn-outline-primary', !data.voted);
                    }
                } else {
                    alert(data.error || 'Failed to upvote the issue.');
                }
            } catch (error) {
                console.error('Upvote error:', error);
                alert('An error occurred while upvoting. Please try again.');
            }
        }

        function attachUpvoteListeners() {
            document.querySelectorAll('.upvote-btn').forEach(button => {
                if (button.dataset.listenerAttached !== 'true') {
                    button.addEventListener('click', function() {
                        {% if current_user.is_authenticated %}
                            upvoteIssue(this.dataset.issueId);
                        {% else %}
                            alert('Please login to upvote an issue.');
                        {% endif %}
                    });
                    button.dataset.listenerAttached = 'true';
                }
            });
        }

        map.on('popupopen', attachUpvoteListeners);

        // Reporting logic
        {% if current_user.is_authenticated %}
            const latInput = document.getElementById('lat-input');
            const lngInput = document.getElementById('lng-input');
            const issueForm = document.getElementById('issue-form');
            const submitBtn = document.getElementById('submit-issue-btn');
            const descriptionInput = document.getElementById('description') || document.querySelector('textarea[name="description"]');

            if (!descriptionInput) {
                console.error('Description input not found');
            }

            async function submitNewIssue() {
                const formData = new FormData(issueForm);
                try {
                    const response = await fetch("{{ url_for('main.report_issue') }}", {
                        method: 'POST',
                        body: formData,
                        credentials: 'same-origin'
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    if (data.success) {
                        const newIssue = data.issue;
                        let popupContent = `
                            <b>${newIssue.title || 'Untitled'}</b>
                            <hr class="my-1">
                            <div class="d-flex justify-content-between align-items-center">
                                <span id="upvote-count-${newIssue.id}">0 Upvotes</span>
                                <button class="btn btn-sm btn-outline-primary upvote-btn" data-issue-id="${newIssue.id}">
                                    <i class="bi bi-hand-thumbs-up"></i> Vote
                                </button>
                            </div>
                            <a href="/issue/${newIssue.id}" class="btn btn-outline-secondary btn-sm mt-2 w-100">View Details</a>
                        `;
                        L.marker([newIssue.lat, newIssue.lng], { icon: defaultIcon }).addTo(map)
                            .bindPopup(popupContent).openPopup();
                        attachUpvoteListeners();
                        reportModal.hide();
                        issueForm.reset();
                        const photoInput = issueForm.querySelector('input[type="file"]');
                        if (photoInput) photoInput.value = '';
                    } else {
                        let errorMessages = "Please fix the following issues:\n";
                        for (const field in data.errors) {
                            errorMessages += `\n- ${field}: ${data.errors[field].join(', ')}`;
                        }
                        alert(errorMessages);
                    }
                } catch (error) {
                    console.error('Submission error:', error);
                    alert('An error occurred while submitting the issue. Please try again.');
                }
            }

            map.on('click', async function(e) {
                if (e.originalEvent.target.closest('.leaflet-control, .leaflet-control-container')) return;

                const lat = e.latlng.lat;
                const lng = e.latlng.lng;

                // Show a temporary "loading" message
                const locationInput = document.getElementById('location-text');
                locationInput.value = 'Fetching address...';

                // Clear any drawn shapes if user decides to click instead
                drawnItems.clearLayers();
                document.getElementById('geojson-input')?.remove();

                // Reset other form fields and set coordinates
                issueForm.reset();
                latInput.value = lat;
                lngInput.value = lng;
                reportModal.show();

                // Call our new reverse-geocode endpoint
                const response = await fetch("{{ url_for('main.reverse_geocode') }}", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ lat: lat, lng: lng })
                });
                const data = await response.json();

                // Populate the location field with the result
                locationInput.value = data.address || 'Could not find address.';
            });


            submitBtn.addEventListener('click', async function() {
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Checking...';
                try {
                    const checkResponse = await fetch("{{ url_for('main.check_duplicates') }}", {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            lat: latInput.value,
                            lng: lngInput.value,
                            description: descriptionInput ? descriptionInput.value : ''
                        }),
                        credentials: 'same-origin'
                    });
                    if (!checkResponse.ok) {
                        throw new Error(`HTTP error! status: ${checkResponse.status}`);
                    }
                    const checkData = await checkResponse.json();
                    if (checkData.is_duplicate) {
                        const proceed = confirm(`This looks like a duplicate of an existing issue:\n\n"${checkData.duplicate_title}"\n\nWould you like to upvote the existing issue instead?`);
                        if (proceed) {
                            await upvoteIssue(checkData.duplicate_id);
                            reportModal.hide();
                        } else {
                            await submitNewIssue();
                        }
                    } else {
                        await submitNewIssue();
                    }
                } catch (error) {
                    console.error('Duplicate check error:', error);
                    alert('An error occurred while checking for duplicates. Please try again.');
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = 'Submit Report';
                }
            });
        {% else %}
            map.on('click', function(e) {
                // Check if the click target is the map, not a control
                const target = e.originalEvent.target;
                if (!target.closest('.leaflet-control')) {
                    L.popup()
                        .setLatLng(e.latlng)
                        .setContent('Please <a href="{{ url_for("main.login") }}">login</a> to report an issue.')
                        .openOn(map);
                }
            });
        {% endif %}
    </script>
{% endblock %}