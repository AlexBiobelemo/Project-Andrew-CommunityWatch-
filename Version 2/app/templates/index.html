{% extends "base.html" %}

{% block content %}
<div id="map" data-issues='{{ issues_data | tojson }}'></div>

<!-- Report Issue Modal -->
<div class="modal fade" id="reportModal" tabindex="-1" aria-labelledby="reportModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="reportModalLabel">Report a New Issue</h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="issue-form" enctype="multipart/form-data">
          {{ issue_form.hidden_tag() }}
          <input type="hidden" id="lat-input" name="lat">
          <input type="hidden" id="lng-input" name="lng">

          <div class="mb-3">
            {{ issue_form.category.label(class="form-label") }}
            {{ issue_form.category(class="form-select") }}
          </div>
          <div class="mb-3">
            {{ issue_form.location_text.label(class="form-label") }}
            {{ issue_form.location_text(class="form-control", id="location-text", readonly=True) }}
          </div>
          <div class="mb-3">
            {{ issue_form.description.label(class="form-label") }}
            {{ issue_form.description(class="form-control", rows="3") }}
          </div>
          <div class="mb-3">
            {{ issue_form.photo.label(class="form-label") }}
            {{ issue_form.photo(class="form-control") }}
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" id="submit-issue-btn">Submit Report</button>
      </div>
    </div>
  </div>
</div>

<style>
  .leaflet-control-locate a {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 34px;
    height: 34px;
    background-color: #fff;
    border: 2px solid rgba(0, 0, 0, 0.2);
    border-radius: 4px;
  }
  .leaflet-control-locate a:hover {
    background-color: #f4f4f4;
  }
</style>

<script>
// Configuration
const CONFIG = {
  map: {
    center: [4.9248, 6.2647],
    zoom: 13,
    maxZoom: 19,
    tileLayers: {
      street: {
        url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      },
      satellite: {
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
      },
      terrain: {
        url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
        maxZoom: 17,
        attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
      }
    }
  },
  icons: {
    Reported: new L.Icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    }),
    'In Progress': new L.Icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    }),
    Resolved: new L.Icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    })
  }
};

// Utility Functions
const select = id => document.getElementById(id);
const showSpinner = btn => {
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Checking...';
};
const hideSpinner = (btn, text) => {
  btn.disabled = false;
  btn.innerHTML = text;
};

// Map Initialization
const initMap = () => {
  const map = L.map('map').setView(CONFIG.map.center, CONFIG.map.zoom);
  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  // Tile Layers
  const layers = {
    'Street View': L.tileLayer(CONFIG.map.tileLayers.street.url, {
      maxZoom: CONFIG.map.maxZoom,
      attribution: CONFIG.map.tileLayers.street.attribution
    }).addTo(map),
    'Satellite View': L.tileLayer(CONFIG.map.tileLayers.satellite.url, {
      maxZoom: CONFIG.map.maxZoom,
      attribution: CONFIG.map.tileLayers.satellite.attribution
    }),
    'Terrain View': L.tileLayer(CONFIG.map.tileLayers.terrain.url, {
      maxZoom: CONFIG.map.tileLayers.terrain.maxZoom,
      attribution: CONFIG.map.tileLayers.terrain.attribution
    })
  };
  L.control.layers(layers).addTo(map);

  // Draw Control
  const drawControl = new L.Control.Draw({
    edit: { featureGroup: drawnItems },
    draw: { polygon: true, polyline: true, rectangle: true, circle: false, marker: false }
  });
  map.addControl(drawControl);

  // Locate Control
  L.Control.Locate = L.Control.extend({
    onAdd(map) {
      const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-locate');
      const button = L.DomUtil.create('a', 'leaflet-bar-part', container);
      button.href = '#';
      button.title = 'Go to my location';
      button.innerHTML = '<i class="bi bi-crosshair" style="font-size: 1.2rem;"></i>';
      L.DomEvent.on(button, 'click', e => {
        L.DomEvent.preventDefault(e);
        if (!navigator.geolocation) {
          alert('Geolocation is not supported by your browser.');
          return;
        }
        navigator.geolocation.getCurrentPosition(
          ({ coords: { latitude, longitude } }) => {
            map.setView([latitude, longitude], 16);
            L.marker([latitude, longitude]).addTo(map)
              .bindPopup('You are here.').openPopup();
          },
          ({ code, message }) => {
            const messages = {
              1: 'Geolocation permission denied. Please enable location services.',
              2: 'Location information is unavailable.',
              3: 'The request to get your location timed out.'
            };
            alert(messages[code] || message);
          },
          { timeout: 10000, enableHighAccuracy: true }
        );
      });
      return container;
    }
  });
  L.control.locate = opts => new L.Control.Locate(opts);
  L.control.locate({ position: 'bottomright' }).addTo(map);

  // GeoSearch Control
  if (typeof GeoSearch !== 'undefined') {
    try {
      const searchControl = new GeoSearch.GeoSearchControl({
        provider: new GeoSearch.OpenStreetMapProvider(),
        style: 'button'
      });
      map.addControl(searchControl);
      map.on('layeradd', ({ layer }) => {
        if (layer instanceof GeoSearch.GeoSearchControl) {
          const searchContainer = document.querySelector('.geosearch-bar');
          if (searchContainer) {
            L.DomEvent.on(searchContainer, 'click', e => L.DomEvent.stopPropagation(e));
          }
        }
      });
    } catch (error) {
      console.error('Error initializing GeoSearchControl:', error);
    }
  }

  return { map, drawnItems };
};

// Issue Markers
const initIssues = (map) => {
  const markers = L.markerClusterGroup();
  const issues = JSON.parse(select('map').dataset.issues || '[]');
  const defaultIcon = CONFIG.icons.Reported;

  issues.forEach(issue => {
    if (!issue.lat || !issue.lng || !issue.id) return;
    const icon = CONFIG.icons[issue.status] || defaultIcon;
    const buttonClass = issue.user_has_voted ? 'btn-primary' : 'btn-outline-primary';
    const popupContent = `
      <b>${issue.title || 'Untitled'}</b>
      <hr class="my-1">
      <div class="d-flex justify-content-between align-items-center">
        <span id="upvote-count-${issue.id}">${issue.upvotes || 0} Upvotes</span>
        <button class="btn btn-sm ${buttonClass} upvote-btn" data-issue-id="${issue.id}">
          <i class="bi bi-hand-thumbs-up"></i> Vote
        </button>
      </div>
      <a href="/issue/${issue.id}" class="btn btn-outline-secondary btn-sm mt-2 w-100">View Details</a>
    `;
    markers.addLayer(L.marker([issue.lat, issue.lng], { icon }).bindPopup(popupContent));
  });

  map.addLayer(markers);
};

// Upvote Functionality
const upvoteIssue = async (issueId) => {
  try {
    const response = await fetch(`/upvote/${issueId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin'
    });
    if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
    const { success, upvote_count, voted, error } = await response.json();
    if (success) {
      const countEl = select(`upvote-count-${issueId}`);
      if (countEl) countEl.textContent = `${upvote_count} Upvotes`;
      const button = document.querySelector(`.upvote-btn[data-issue-id="${issueId}"]`);
      if (button) {
        button.classList.toggle('btn-primary', voted);
        button.classList.toggle('btn-outline-primary', !voted);
      }
    } else {
      alert(error || 'Failed to upvote the issue.');
    }
  } catch (error) {
    console.error('Upvote error:', error);
    alert('An error occurred while upvoting. Please try again.');
  }
};

// Report Submission
const initReporting = (map, drawnItems) => {
  const reportModal = new bootstrap.Modal(select('reportModal'));
  const issueForm = select('issue-form');
  const submitBtn = select('submit-issue-btn');
  const latInput = select('lat-input');
  const lngInput = select('lng-input');
  const locationInput = select('location-text');
  const descriptionInput = select('description') || document.querySelector('textarea[name="description"]');
  const defaultIcon = CONFIG.icons.Reported;

  const submitNewIssue = async () => {
    const formData = new FormData(issueForm);
    try {
      const response = await fetch("{{ url_for('main.report_issue') }}", {
        method: 'POST',
        body: formData,
        credentials: 'same-origin'
      });
      if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
      const { success, issue, errors } = await response.json();
      if (success) {
        const popupContent = `
          <b>${issue.title || 'Untitled'}</b>
          <hr class="my-1">
          <div class="d-flex justify-content-between align-items-center">
            <span id="upvote-count-${issue.id}">0 Upvotes</span>
            <button class="btn btn-sm btn-outline-primary upvote-btn" data-issue-id="${issue.id}">
              <i class="bi bi-hand-thumbs-up"></i> Vote
            </button>
          </div>
          <a href="/issue/${issue.id}" class="btn btn-outline-secondary btn-sm mt-2 w-100">View Details</a>
        `;
        L.marker([issue.lat, issue.lng], { icon: defaultIcon })
          .addTo(map)
          .bindPopup(popupContent)
          .openPopup();
        attachUpvoteListeners();
        reportModal.hide();
        issueForm.reset();
        issueForm.querySelector('input[type="file"]').value = '';
        drawnItems.clearLayers();
        select('geojson-input')?.remove();
      } else {
        alert(`Please fix the following issues:\n${Object.entries(errors).map(([field, errs]) => `- ${field}: ${errs.join(', ')}`).join('\n')}`);
      }
    } catch (error) {
      console.error('Submission error:', error);
      alert('An error occurred while submitting the issue. Please try again.');
    }
  };

  map.on(L.Draw.Event.CREATED, ({ layer }) => {
    drawnItems.addLayer(layer);
    const geojson = layer.toGeoJSON();
    const { lat, lng } = layer.getBounds().getCenter();
    latInput.value = lat;
    lngInput.value = lng;
    let geojsonInput = select('geojson-input');
    if (!geojsonInput) {
      geojsonInput = document.createElement('input');
      geojsonInput.type = 'hidden';
      geojsonInput.id = 'geojson-input';
      geojsonInput.name = 'geojson';
      issueForm.appendChild(geojsonInput);
    }
    geojsonInput.value = JSON.stringify(geojson.geometry);
    reportModal.show();
  });

  map.on('click', async ({ latlng: { lat, lng }, originalEvent: { target } }) => {
    if (target.closest('.leaflet-control, .leaflet-control-container')) return;
    locationInput.value = 'Fetching address...';
    drawnItems.clearLayers();
    select('geojson-input')?.remove();
    issueForm.reset();
    latInput.value = lat;
    lngInput.value = lng;
    {% if current_user.is_authenticated %}
      try {
        const response = await fetch("{{ url_for('main.reverse_geocode') }}", {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lat, lng })
        });
        if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
        const { address } = await response.json();
        locationInput.value = address || 'Could not find address.';
      } catch (error) {
        console.error('Geocode error:', error);
        locationInput.value = 'Could not find address.';
      }
      reportModal.show();
    {% else %}
      L.popup()
        .setLatLng([lat, lng])
        .setContent('Please <a href="{{ url_for("main.login") }}">login</a> to report an issue.')
        .openOn(map);
    {% endif %}
  });

  submitBtn.addEventListener('click', async () => {
    {% if current_user.is_authenticated %}
      showSpinner(submitBtn);
      try {
        const checkResponse = await fetch("{{ url_for('main.check_duplicates') }}", {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            lat: latInput.value,
            lng: lngInput.value,
            description: descriptionInput?.value || ''
          }),
          credentials: 'same-origin'
        });
        if (!checkResponse.ok) throw new Error(`HTTP error: ${checkResponse.status}`);
        const { is_duplicate, duplicate_id, duplicate_title } = await checkResponse.json();
        if (is_duplicate) {
          const proceed = confirm(`This looks like a duplicate of an existing issue:\n\n"${duplicate_title}"\n\nWould you like to upvote the existing issue instead?`);
          if (proceed) {
            await upvoteIssue(duplicate_id);
            reportModal.hide();
          } else {
            await submitNewIssue();
          }
        } else {
          await submitNewIssue();
        }
      } catch (error) {
        console.error('Duplicate check error:', error);
        alert('An error occurred while checking for duplicates. Please try again.');
      } finally {
        hideSpinner(submitBtn, 'Submit Report');
      }
    {% else %}
      alert('Please login to submit an issue.');
    {% endif %}
  });

  const attachUpvoteListeners = () => {
    document.querySelectorAll('.upvote-btn:not([data-listener-attached="true"])').forEach(button => {
      button.addEventListener('click', () => {
        {% if current_user.is_authenticated %}
          upvoteIssue(button.dataset.issueId);
        {% else %}
          alert('Please login to upvote an issue.');
        {% endif %}
      });
      button.dataset.listenerAttached = 'true';
    });
  };

  map.on('popupopen', attachUpvoteListeners);
};

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  const { map, drawnItems } = initMap();
  initIssues(map);
  {% if current_user.is_authenticated %}
    initReporting(map, drawnItems);
  {% endif %}
});
</script>
{% endblock %}